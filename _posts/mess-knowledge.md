---
title: 杂乱的知识点总结
date: 2019-07-15 21:11:35
tags:
- 杂乱知识
categories:
- 杂乱
---

5种 IO模型

作者：levin





IO 多路复用是 5 种 I/O 模型中的第 3 种，对各种模型讲个故事，描述下区别：

故事情节为：老李去买火车票，三天后买到一张退票。参演人员（老李，黄牛，售票员，快递员），往返车站耗费 1 小时。

1. **阻塞 I/O 模型**

老李去火车站买票，排队三天买到一张退票。

耗费：在车站吃喝拉撒睡 3 天，其他事一件没干。



2. **非阻塞 I/O 模型**

老李去火车站买票，隔 12 小时去火车站问有没有退票，三天后买到一张票。

耗费：往返车站 6 次，路上 6 小时，其他时间做了好多事。



3.**I/O 复用模型**

[1.select/poll](https://link.zhihu.com/?target=http%3A//1.select/poll)

老李去火车站买票，委托黄牛，然后每隔 6 小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。 

耗费：往返车站 2 次，路上 2 小时，黄牛手续费 100 元，打电话 17 次



2.epoll

老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。 

耗费：往返车站 2 次，路上 2 小时，黄牛手续费 100 元，无需打电话



4. **信号驱动 I/O 模型**

老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。  

耗费：往返车站 2 次，路上 2 小时，免黄牛费 100 元，无需打电话



5. **异步 I/O 模型**

老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。 

耗费：往返车站 1 次，路上 1 小时，免黄牛费 100 元，无需打电话



1 同 2 的区别是：自己轮询

2 同 3 的区别是：委托黄牛

3 同 4 的区别是：电话代替黄牛

4 同 5 的区别是：电话通知是自取还是送票上门

IO多路复用

在同一线程内，通过拨开关方式，同时传输多个IO流，提高服务器吞吐能力

*一个请求到来了，nginx 使用 epoll 接收请求的过程是怎样的”， 多看看这个图就了解了。提醒下，ngnix 会有很多链接进来， epoll 会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。*

### select poll epoll比较

1. select 会修改传入的参数数组，这个对于一个需要调用很多次的函数，是非常不友好的。

2.  select 如果任何一个 sock (I/O stream) 出现了数据，select 仅仅会返回，但是并不会告诉你是那个 sock 上有数据，于是你只能自己一个一个的找，10 几个 sock 可能还好，要是几万的 sock 每次都找一遍，这个无谓的开销就颇有海天盛筵的豪气了。

3. select 只能监视 1024 个链接， 这个跟草榴没啥关系哦，linux 定义在头文件中的，参见 *FD_SETSIZE。*

4. select 不是线程安全的，如果你把一个 sock 加入到 select, 然后突然另外一个线程发现，尼玛，这个 sock 不用，要收回。对不起，这个 select 不支持的，如果你丧心病狂的竟然关掉这个 sock, select 的标准行为是。。呃。。不可预测的， 这个可是写在文档中的哦.

   #### 14 年以后 (1997 年）一帮人又实现了 poll,  poll 修复了 select 的很多问题，比如

   poll 去掉了 1024 个链接的限制，于是要多少链接呢， 主人你开心就好。
    poll 从设计上来说，不再修改传入数组，不过这个要看你的平台了，所以行走江湖，还是小心为妙。

   1. epoll 现在是线程安全的。 

   2. epoll 现在不仅告诉你 sock 组里面数据，还会告诉你具体哪个 sock 有数据，你不用自己去找了。

   3. epoll 有个致命的缺点。。只有 linux 支持

     参考:

     [IO多路复用]: https://www.zhihu.com/question/32163005/answer/55772739	"IO多路复用"

     ### cookie 与session
   
     ------
   
     ### cookie
   
     - http请求是无状态的，即使第一次和服务器建立连接登录成功后，第二次请求，服务器仍然不知道当前请求是哪个用户，cookie就是为了解决该问题，第一次登录服务器后，服务器发回一些数据给浏览器，浏览器保存在在本地，当用户第二次请求时候，会自动把上次请求存储的cookie数据自动携带给服务器，服务器通过浏览器携带的数据即可判断当前发起请求的是哪个用户。
   
     - cookie存储数据量有限，不同浏览器有不同的存储大小，一般不超过4kb，有些浏览器最多支持20个cookie，适合存储小量数据。
   
       ### session
   
       session和cookie类似，只是session存储在服务器端，因此更安全，不容易被窃取，但是占用服务器资源，但是对于现在服务器来说存储这些资源绰绰有余。
   
       cookie 和ssession结合使用
   
       1 存储在服务端，通过cookie存储一个session_id，具体数据保存在session中，如果用户已经登录，服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该 session_id 携带上来，服务器根据 session_id 在 session 库中获取用户的 session 数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做 server side session。
   
       2、将 session 数据加密，然后存储在 cookie 中。这种专业术语叫做 client side session。flask 采用的就是这种方式，但是也可以替换成其他形式。
   
       登录信息保存在服务器，其他保存在cookie
   
       session保存在服务器，客户端不知道session中信息，cookie保存在客户端，服务器能够知道cookie信息
   
       session中保存的是对象，cookie中保存的为字符串
   
       session不能区分路径，用户在访问同一个网站时候，所有的session在任何一个地方都可以访问到，而cookie如果设置路径参数，那么同一个网站中不同路径下的cookie是访问不到的。
   
       ```bash
       session和cookie都是服务器产生的，都是键值对应的。
       **  session是保存在服务器的，服务器会生成对应的session文件，cookie是返回给客户端的，然后客户端在存储相关文件。**
           session在服务器的入口是ID，然后服务器查出对应的的值，通过类似cookie的形式，返回给客户端(相当于买电影票)。客户端（浏览器），会在发送请求的时候，自动将本地存活的cookie封装在信息头中发送给服务器(相当于，看电影验票)。
           **session和cookie都是有生命周期的。**
           cookie的生命周期受到：cookie自身生命周期以及客户端是否保留cookie文件的影响(相当于，电影票没看确丢了)。
           session的生命周期受到：session自身的存活周期以及客户端是否关闭的影响。
           **session和cookie都是有作用域的。**
       ```
   
     ###  
   
     > ###### 三种跨平台桌面框架
NWJS      https://nwjs.io/
HEX       http://hex.youdao.com/zh-cn/tutorial/index.html
Electron  https://Electronjs.org/docs


